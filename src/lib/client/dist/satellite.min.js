/**
 * This file is automatically generated by satellite framework, please *DO NOT* modify the file. 
 * Generate time : Wed Aug 31 2016 17:03:56 GMT+0800 (CST). 
 **/

/**
 * Original script file : src/lib/client/clientutils.js. 
 **/

const META_INFORMATION_ID = "QiwurScrapingMetaInformation";

/**
 * Check if the variables are defined
 * @param variables object with format : {varName1 : var1, varName2 : var2, ..., varNameN : varN}
 * @return object A json object to report the existence of each variable
 * */
function __warps__checkVariables(variables) {
	"use strict";

	var report = {};
	for (var variable in variables) {
		if (variables[variable] != undefined) {
			report[variable] = typeof(variables[variable]);
		}
		else {
			report[variable] = false;
		}
	}
	return report;
}


/**
 * Clones an object.
 *
 * @param  Mixed  o
 * @return Mixed
 */
function __warps__clone(o) {
	"use strict";
	return JSON.parse(JSON.stringify(o));
}

/**
 * Object recursive merging utility.
 *
 * @param  {Object}  origin  the origin object
 * @param  {Object}  add     the object to merge data into origin
 * @param  {Object}  opts    optional options to be passed in
 * @return {Object}
 */
function __warps__mergeObjects(origin, add, opts) {
	"use strict";

	if (!add) {
		return origin;
	}
	
	var options = opts || {},
		keepReferences = options.keepReferences;

	for (var p in add) {
		if (add[p] && add[p].constructor === Object) {
			if (origin[p] && origin[p].constructor === Object) {
				origin[p] = __warps__mergeObjects(origin[p], add[p]);
			} else {
				origin[p] = keepReferences ? add[p] : __warps__clone(add[p]);
			}
		} else {
			origin[p] = add[p];
		}
	}
	
	return origin;
}

/**
 * TODO : move all free functions into a class
 * */
function __warps__visualizeHumanize() {
	"use strict";

	// traverse the DOM and compute necessary data, we must compute data before we perform humanization
	new WarpsElementTraversor(new WarpsElementVisitor()).traverse(document.body);

	// do some action like a real user
	__warps__humanize(document.body);

	// if any script error occurs, the flag can NOT be seen
	document.body.setAttribute("data-error", '0');
}

/**
 * Fetch all <a> elements from the page and return
 * the ones which contains a href starting with 'http://'
 * 
 * @param mainAreaSelector main area selector
 * @param urlRegex url regex in main area
 * 
 * */
function __warps__searchLinks(mainAreaSelector, urlRegex) {
	var filter = Array.prototype.filter;
	var map = Array.prototype.map;

	var links = document.querySelectorAll(mainAreaSelector + " a");
	var urls = map.call(filter.call(links, function(link) {
		return new RegExp(urlRegex).test(link.href);
	}), function(link) {
		// TODO : add a normalize util
		var pos = link.href.indexOf("#");
		return link.href.substring(0, pos == -1 ? 200 : pos);
	});

	// make it unique
	urls = urls.sort().filter(function(link, i, arr) {
		return link && link.length > 0 && (i == arr.indexOf(link));
	});

	return urls;
}

function __warps__relativeToAbsolute(url) {
	if (url.indexOf("//") == 0) {
		url = "http:" + url;
	}

    var arr = url.split("/") // Cut the url up into a array
    while(!!~arr.indexOf("..")){ // If there still is a ".." in the array
        arr.splice(arr.indexOf("..") - 1, 2); // Remove the ".." and the element before it.
    }
    return arr.join("/"); // Rebuild the url and return it.
}

function __warps_createCaptureArea(captureAreaSelector) {
	// TODO : remove dependency to jQuery
	jQuery("<div class='WarpsCaptureArea' style='position:absolute; top:0; left:0; min-width:1000px; min-height:1000px; z-index:1000; display:block'>" +
			"<div class='holder' style='position:absolute; top:0px; left:20px; min-width:20px; min-height:20px; padding:0 40px; display:block'></div>" +
			"</div>")
		.prependTo('body');

	var holder = jQuery('.WarpsCaptureArea > div.holder');
	var target = jQuery(captureAreaSelector);
	// __utils__.echo("Target tag name " + target.prop('tagName'));
	var counter = 4;
	while (target.prop('tagName') != 'DIV' && counter-- > 0) {
		target = target.parent();
	}
	holder.append(target.clone());
	holder.width(target.width());
	holder.height(target.height());
}

function __warps_cleanCaptureArea() {
	jQuery('.WarpsCaptureArea').remove();
}

function __warps_insertImage(nearBy, name, imagePath) {
	var counter = 4;
	var neighbor = jQuery(nearBy);
	while (neighbor.prop('tagName') != 'DIV' && counter-- > 0) {
		neighbor = neighbor.parent();
	}

	var insert = neighbor.clone().html('')
		.attr('class', 'monitor-inserted')
		.attr('name', name)
		.attr('value', imagePath)
		.attr('label', 'Captured');
	var image = "<img src='" + imagePath + "' />";
	insert.append('<div>' + name + '</div>');
	insert.append('<div>' + image + '</div>');

	neighbor.after(insert);
}

/**
 * Get attribute as an integer
 * */
function __warps_getAttributeAsInt(node, attrName, defaultValue) {
    if (!defaultValue) {
        defaultValue = 0;
    }

    var value = node.getAttribute(attrName);
    if (!value) {
        value = defaultValue;
    }

    return parseInt(value);
}

/**
 * Get attribute as an integer
 * */
function __warps_getReadableNodeName(node) {
    var name = node.tagName
    + (node.id ? ("#" + node.id) : "")
    + (node.className ? ("#" + node.className) : "");

    var seq = __warps_getAttributeAsInt(node, "_seq", -1);
    if (seq >= 0) {
        name += "-" + seq;
    }

    return name;
}

/**
 * Clean node's textContent
 * @param textContent {String} the string to clean
 * @return {String} The clean string
 * */
function __warps_getCleanTextContent(textContent) {

	// all control characters
	// @see http://www.asciima.com/
	textContent = textContent.replace(/[\x00-\x1f]/g, " ");

	// combine all blanks into one " " character
	textContent = textContent.replace(/\s+/g, " ");

	return textContent.trim();
}

/**
 * Get clean, merged textContent from node list
 * @param nodeOrList {NodeList|Array|Node} the node from which we extract the content
 * @return {String} The clean string, "" if no text content available.
 * */
function __warps_getMergedTextContent(nodeOrList) {
	if (!nodeOrList) {
		return "";
	}

	if (nodeOrList instanceof  Node) {
		return __warps_getTextContent(nodeOrList);
	}

	var content = "";
	for (var i = 0; i < nodeOrList.length; ++i) {
		if (i > 0) {
			content += " ";
		}
		content += __warps_getTextContent(nodeOrList[i]);
	}

	return content;
}

/**
 * Get clean node's textContent
 * @param node {Node} the node from which we extract the content
 * @return {String} The clean string, "" if no text content available.
 * */
function __warps_getTextContent(node) {
	if (!node || !node.textContent) {
		return "";
	}

	return __warps_getCleanTextContent(node.textContent);
}

/**
 * Original script file : src/lib/client/element_traversor.js. 
 **/

/**
 * Created by vincent on 16-5-17.
 */

"use strict";

/**
 * Create a new traversor.
 * @param visitor {WarpsElementVisitor} a class implementing the {@link WarpsElementVisitor} interface, to be called when visiting each ele.
 * @param options {Object} options, currently, only one option : options.diagnosis(= false);
 */
function WarpsElementTraversor(visitor) {
    this.visitor = visitor;
    this.options = {
        diagnosis : false
    };

    var options = null;
    if (arguments.length > 1) {
        options = arguments[1];
    }
    if (options) {
        // override default options
        for (var prop in options) {
            if (options[prop]) {
                this.options[prop] = options[prop];
            }
        }
    }
}

/**
 * Start a depth-first traverse of the root and all of its descendants.
 * @param root {HTMLElement} the root ele point to traverse.
 */
WarpsElementTraversor.prototype.traverse = function(root) {
    if (!root) {
        __utils__.log("Invalid root to traverse.", "warn");
        return;
    }
    
    var ele = root;
    var depth = 0;
    
    while (ele && !this.visitor.isStopped()) {
        this.visitor.head(ele, depth);

        if (ele.children.length > 0) {
            ele = ele.children[0];
            depth++;
        } else {
            while (!ele.nextElementSibling && depth > 0 && !this.visitor.isStopped()) {
                this.visitor.tail(ele, depth);
                ele = ele.parentNode;
                depth--;
                
                if (this.options.diagnosis) {
                    this.diagnosis(ele);
                }
            }
            
            this.visitor.tail(ele, depth);
            if (ele == root) {
                // __utils__.echo("-----back to root, depth " + depth);
                break;
            }
            
            ele = ele.nextElementSibling;
        }
    }
};

WarpsElementTraversor.prototype.diagnosis = function(ele, depth) {
    var info = ele + ", nodeType : " + ele.nodeType + ", nodeName : " + ele.nodeName;

    if (ele.nodeName === "A") {
        info += ", children count : " + ele.children.length;
        for (var i = 0; i < ele.children.length; ++i) {
            info += ", " + ele.children[i].nodeName;
        }
    }

    __utils__.echo(info);
};

/**
 * Original script file : src/lib/client/element_visitor.js. 
 **/

/**
 * Created by vincent on 16-5-17.
 *
 * Element Visitor : used with Element ElementTraversor together
 */

// TODO : record all features required
const VISION_SCHEMA = ["top", "left", "width", "height"];
const VISUALIZE_TAGS = ["BODY", "DIV", "A", "IMG", "TABLE", "UL", "DL", "H1", "H2", "H3"];
const VISION_SCHEMA_STRING = "top-left-width-height";

"use strict";

/**
 * Create a new WarpsElementVisitor.
 */
var WarpsElementVisitor = function() {
    // this.schema = ["descend"];
    this.sequence = 0;
    this.stopped = false;

    var metadata = document.querySelector("#" + META_INFORMATION_ID);
    if (metadata) {
        // already exists
        this.stopped = true;
        return;
    }

    this.generateMetadata();
};

/**
 * Generate meta data
 *
 * MetaInformation version :
 * No version : as the same as 0.1.0, the first div was selected as the holder
 * 0.2.0 : add a input element at the end of body element
 * 0.2.1 : add "vi" attribute for each (important) element, deprecate "data-" series
 * 		to deduce file size
 * 0.2.2 : coming soon...
 * */
WarpsElementVisitor.prototype.generateMetadata = function() {
    document.body.setAttribute("data-url", document.URL);

    var ele = document.createElement("input");
    ele.setAttribute("type", "hidden");
    ele.setAttribute("id", META_INFORMATION_ID);
    ele.setAttribute("data-domain", document.domain);
    ele.setAttribute("data-version", "0.2.1");
    ele.setAttribute("data-url", document.URL);
    ele.setAttribute("data-base-uri", document.baseURI);
    ele.setAttribute("data-vision-schema", VISION_SCHEMA_STRING);

    document.body.appendChild(ele);
};

/**
 * Check if stopped
 */
WarpsElementVisitor.prototype.isStopped = function() {
    return this.stopped;
};

/**
 * Enter the element for the first time
 * @param ele {HTMLElement} the ele to enter
 * @param  depth {Number} the depth in the DOM
 */
WarpsElementVisitor.prototype.head = function(ele, depth) {
    ele.setAttribute("_descend", "0");
    ele.setAttribute("_depth", depth.toString());

    this.calcSelfIndicator(ele);

    this.makeUrlAbsolute(ele);
};

/**
 * About to leaving the the element
 * @param ele {HTMLElement} the ele visited
 * @param  depth {Number} the depth in the DOM
 */
WarpsElementVisitor.prototype.tail = function(ele, depth) {
    var current = ele;
    var parent = current.parentNode;

    if (!parent) {
        return;
    }

    var myDescends = __warps_getAttributeAsInt(current, "_descend", 0);
    var lastParentDescends = __warps_getAttributeAsInt(parent, "_descend", 0);
    var currentParentDescends = lastParentDescends + myDescends + 1;

    // this.report(ele);

    parent.setAttribute("_descend", currentParentDescends);

    // if (VISUALIZE_TAGS.indexOf(ele.tagName) != -1) {
    // }
    // Calculate every element's vision information
    var vision = __warps__getVisionInfo(ele, VISION_SCHEMA);
    if (vision) {
        ele.setAttribute('vi', vision);
    }
};

/**
 * Calculate the give element statistic information
 * @param ele {HTMLElement} the element to calculate
 */
WarpsElementVisitor.prototype.makeUrlAbsolute = function(ele) {
    var urls = {
        href : ele.getAttribute("href"),
        src : ele.getAttribute("src"),
        "data-src" : ele.getAttribute("data-src")
    };

    for (var name in urls) {
        if (urls[name]) {
            var absoluteUrl = __warps__relativeToAbsolute(urls[name]);
            ele.setAttribute(name, absoluteUrl);
        }
    }
};

/**
 * Calculate the give element statistic information
 * @param ele {HTMLElement} the element to calculate
 */
WarpsElementVisitor.prototype.calcSelfIndicator = function(ele) {
    // var descend = __warps_getAttributeAsInt(ele, "_descend", 0);
    //
    ele.setAttribute("_seq", (++this.sequence).toString());
};

/**
 * Report the element statistic information
 * @param ele {HTMLElement} the element to report
 */
WarpsElementVisitor.prototype.report = function(ele) {
    var descends = __warps_getAttributeAsInt(ele, "_descend", 0);

    __utils__.echo(ele.tagName
        + (ele.id ? ("#" + ele.id) : "")
        + (ele.className ? ("#" + ele.className) : "")
        + " has " + descends + " descends");
};

/**
 * Get or set data with given name and value
 * */
WarpsElementVisitor.prototype.data = function(ele, name, value) {
    if (!ele.data) {
        ele.data = [];
    }

    if (!value) {
        return ele.data[name] ? ele.data[name] : undefined;
    }

    ele.data[name] = value;
};

/**
 * Original script file : src/lib/client/humanize.js. 
 **/

var MAX_EVENT_COUNT = 30;

/**
 * TODO : move all free functions into a class
 * */

/**
 * TODO : use __utils__.mouseEvent()
 *
 * Fire an event handler to the specified node. Event handlers can detect that
 * the event was fired programatically by testing for a 'synthetic=true'
 * property on the event object
 * 
 * @param {HTMLNode}
 *            node The node to fire the event handler on.
 * @param {String}
 *            eventName The name of the event without the "on" (e.g., "focus")
 */
function __warps__fireEvent(node, eventName) {
    // Make sure we use the ownerDocument from the provided node to avoid
    // cross-window problems
    var doc;
    if (node.ownerDocument) {
        doc = node.ownerDocument;
    } else if (node.nodeType == 9) {
        // the node may be the document itself, nodeType 9 = DOCUMENT_NODE
        doc = node;
    } else {
        throw new Error("Invalid node passed to fireEvent: " + node.id);
    }

    if (node.dispatchEvent) {
        // Gecko-style approach (now the standard) takes more work
        var eventClass = "";

        // Different events have different event classes.
        // If this switch statement can't map an eventName to an eventClass,
        // the event firing is going to fail.
        switch (eventName) {
        case "click": // Dispatching of 'click' appears to not work correctly
                        // in Safari. Use 'mousedown' or 'mouseup' instead.
        case "mousedown":
        case "mouseup":
        case "mouseover":
            eventClass = "MouseEvents";
            break;

        case "focus":
        case "change":
        case "blur":
        case "select":
            eventClass = "HTMLEvents";
            break;

        default:
            throw "fireEvent: Couldn't find an event class for event '"
                    + eventName + "'.";
            break;
        }
        var event = doc.createEvent(eventClass);

        var bubbles = eventName == "change" ? false : true;
        event.initEvent(eventName, bubbles, true); // All events created as
                                                    // bubbling and cancelable.

        event.synthetic = true; // allow detection of synthetic events
        node.dispatchEvent(event, true);
    } else if (node.fireEvent) {
        // IE-old school style
        var event = doc.createEventObject();
        event.synthetic = true; // allow detection of synthetic events
        node.fireEvent("on" + eventName, event);
    }
};

function __warps__humanize(doc) {
    // mouse over and click each link, notice that the navigation is locked, so it's OK to click the link
    // notice : do not use document.links since it ignores <a> tag without href attribute
    var links = doc.getElementsByTagName("a");
    var eventCount = 0;
    for (var i = 0; i < links.length && eventCount < MAX_EVENT_COUNT; ++i) {
        var link = links[i];

        var noTarget = !link.href;
        noTarget |= link.href.indexOf('void') == 0;
        noTarget |= link.href.indexOf('#') == 0;
        noTarget |= link.href.indexOf('java') == 0;
        noTarget |= link.href.indexOf('script') == 0;

        var hasEvent = link.hasAttribute('onmousedown');
        hasEvent |= link.hasAttribute('onmouseup');
        hasEvent |= link.hasAttribute('onmouseover');
//      hasEvent |= link.hasAttribute('onclick');

        if (noTarget || hasEvent) {
//            __warps__fireEvent(link, 'mousedown');
//            __warps__fireEvent(link, 'mouseup');
            __warps__fireEvent(link, 'mouseover');

            // TODO : research : a click event contains mousedown, mouseup and mouseover?
//            __warps__fireEvent(link, 'click');
            ++eventCount;

            // if any script error occurs, the flag can NOT be seen
            link.setAttribute('data-event-fired', eventCount);

            __warps__fireEvent(link, 'mouseout');
        }
    }

    var fireImageEvent = false;
    if (fireImageEvent) {
        // mouse over and click each image
        var images = doc.getElementsByTagName("img");
        for (var i = 0; i < images.length; ++i) {
            var image = images[i];

            __warps__fireEvent(image, 'mousedown');
            __warps__fireEvent(image, 'mouseup');
            __warps__fireEvent(image, 'mouseover');
            __warps__fireEvent(image, 'click');

            // if any script error occurs, the flag can NOT be seen
            image.setAttribute('data-event-fired', 1);
        }
    }
}

/**
 * Original script file : src/lib/client/visualize.js. 
 **/

/**
 * TODO : move all free functions into a class
 * */

/**
 * Get element offset
 * @return [top, left]
 * */
function __warps__getOffset(ele) {
    var x = 0;
    var y = 0;

    while(ele && !isNaN(ele.offsetLeft) && !isNaN(ele.offsetTop)) {
    	x += ele.offsetLeft - ele.scrollLeft;
        y += ele.offsetTop - ele.scrollTop;

        ele = ele.offsetParent;
    }

    return { top: y, left: x };
}

/**
 * Set robot(monitor) defined element attribute
 * @return [top, left]
 * */
function __warps__setAttribute(ele, key, value) {
    if (value != "0" && value != "0px" && value != "auto") {
        // or use regex : value.match(/[1-9]d+px/g);
        ele.setAttribute(key, value);
    }
}

/**
 * @Deprecated
 * */
function __qiwur__setVisionInfoFull(ele) {
	var offset = __warps__getOffset(ele);

    __warps__setAttribute(ele, 'data-top', offset.top);
    __warps__setAttribute(ele, 'data-left', offset.left);

    if (window.getComputedStyle) {
        var style = window.getComputedStyle(ele, null);
        __warps__setAttribute(ele, 'data-top', style.getPropertyValue("top"));
        __warps__setAttribute(ele, 'data-left', style.getPropertyValue("left"));
        __warps__setAttribute(ele, 'data-width', style.getPropertyValue("width"));
        __warps__setAttribute(ele, 'data-height', style.getPropertyValue("height"));
    }
    else {
        __warps__setAttribute(ele, 'data-client-height', ele.clientHeight);
        __warps__setAttribute(ele, 'data-client-width', ele.clientWidth);

        __warps__setAttribute(ele, 'data-offset-height', ele.offsetHeight);
        __warps__setAttribute(ele, 'data-offset-width', ele.offsetWidth);
        __warps__setAttribute(ele, 'data-offset-left', ele.offsetLeft);
        __warps__setAttribute(ele, 'data-offset-top', ele.offsetTop);

        __warps__setAttribute(ele, 'data-scroll-height', ele.scrollHeight);
        __warps__setAttribute(ele, 'data-scroll-width', ele.scrollWidth);
        __warps__setAttribute(ele, 'data-scroll-left', ele.scrollLeft);
        __warps__setAttribute(ele, 'data-scroll-top', ele.scrollTop);
    }

    __warps__setAttribute(ele, 'data-visualized', 1);
}

/**
 * Visual information. To minimize the document size,
 * we write only the values according to the given schema.
 * 
 * For example : 
 * <div class="product" vi="236 470 980 30">...</div>
 * */
function __warps__getVisionInfo(ele, schema) {
	var vision = "";

	var style = window.getComputedStyle(ele, null);
	var offset = __warps__getOffset(ele);

	var allZero = true;
	for (var i = 0; i < schema.length; ++i) {
		if (i > 0) {
			vision += " ";
		}

		var key = schema[i];
		var value = "";

		if (key == "top") {
			value = offset.top;
		}
		else if (key == "left") {
			value = offset.left;
		}
		else {
			value = style.getPropertyValue(key);
			value = value.replace("px", "");
		}

		if (!isNaN(parseInt(value)) && value != 0) {
			allZero = false;
		}

		vision += value;
	}

	return allZero ? false : vision;
}

/**
 * Compute visualization information
 * @deprecated, use WarpsElementTraversor/WarpsElementVisitor instead
 * */
function __warps__visualize(ele, schema) {
	if (["BODY", "DIV", "A", "IMG", "TABLE", "UL", "DL", "H1", "H2"].indexOf(ele.tagName) != -1) {
		var vision = __warps__getVisionInfo(ele, schema);
		if (vision) {
			ele.setAttribute('vi', vision);
		}
	}

    for(var i = 0; i < ele.childNodes.length; i++) {
    	__warps__visualize(ele.childNodes[i], schema);
    }
}

/**
 * Original script file : src/lib/client/warps_dom_extractor.js. 
 **/

// Note : seems can not come before constants
"use strict";

/**
 * Page extractor
 * @param extractor {JSON} extract rules
 * @param options {Object}
 * */
var WarpsDomExtractor = function Extractor(extractor, options) {
    "use strict";

    if (!options) {
        options = {};
    }

    this.defaults = {
        'metadata' : true,
        'verbose' : false
    };
    /** Extract rules */
    this.extractor = extractor;
    /** Extract options */
    this.options = __warps__mergeObjects(this.defaults, options, null);
    /** Extract rules */
    this.verbose = this.options.verbose;
    /**
     * @var results array [[k1, v1], [k1, v1], ..., [kn, vn]]
     * */
    this.results = [];
};

/**
 * Extract fields from an element using the given rule
 *
 * @param scope {HTMLElement|null} Element to search child elements within,
 *  default scope is window.document
 * @return {Array} contains [k, v] pairs
 * */
WarpsDomExtractor.prototype.extract = function (scope) {
    "use strict";

    if (this.verbose) {
        __utils__.log('WarpsDomExtractor extract', 'debug');
    }

    scope = scope || window.document;

    try {
        if (this.options.metadata) {
            this.extractMetadata();
        }
        if (this.extractor.slim) {
            this.extractBySlimRules(this.extractor.slim, scope);
        }
        if (this.extractor.full) {
            this.extractByFullRules(this.extractor.full, scope);
        }
        if (this.extractor.kv) {
            this.extractByKVRules(this.extractor.kv, scope);
        }
        if (this.extractor.regex) {
            this.extractByRegex(this.extractor.regex, scope);
        }
        if (this.extractor.collection) {
            this.extractCollections(this.extractor.collection, scope);
        }
    }
    catch (e) {
        __utils__.log("Failed to extract page. " + e, "error");
    }

    return this.results;
};

/**
 * Extract metadata
 *
 * @return Array contains [k, v] pairs
 * */
WarpsDomExtractor.prototype.extractMetadata = function () {
    "use strict";

    if (this.verbose) {
        __utils__.log('Extract by slim rules', 'debug');
    }

    var nodeList = __utils__.findAll("head meta");
    for (var i = 0; i < nodeList.length; ++i) {
        var node = nodeList[i];

        var k = node.getAttribute("http-equiv");
        var v = node.getAttribute("content");

        if (k && k.length > 0 && v && v.length > 0 ) {
            var item = {name : k, value : v, type : 'metadata'};
            this.results.push(item);
        }
    }

    return this.results;
};

/**
 * Extract fields from an element using the given rules
 *
 * @param rules {Array|null} extract rules
 * @param scope {HTMLElement|null} Element to search child elements within,
 *  default scope is document
 * @return Array contains [k, v] pairs
 * */
WarpsDomExtractor.prototype.extractBySlimRules = function (rules, scope) {
    "use strict";

    if (this.verbose) {
        __utils__.log('Extract by slim rules', 'debug');
    }

    if (!rules) {
        return this.results;
    }

    if (rules.length % 2 !== 0) {
        __utils__.log('Slim extractor rules length must be even number', 'warn');
        return this.results;
    }

    for (var i = 0; i < rules.length - 1; i += 2) {
        var k = rules[i];
        var selector = rules[i + 1];
        var v = __utils__.findOne(selector, scope);

        if (v && v.textContent) {
            var item = {name : k, value : __warps_getMergedTextContent(v)};
            this.results.push(item);
        }
    }

    return this.results;
};

/**
 * Extract fields from an element using the given regex rule
 *
 * @param rules {Array|null} extract rules
 * @param scope {HTMLElement|null} Element to search child elements within,
 *  default scope is document
 * @return Array contains [k, v] pairs
 * */
WarpsDomExtractor.prototype.extractByRegex = function (rules, scope) {
    "use strict";

    if (this.verbose) {
        __utils__.log('Extract by regex', 'debug');
    }

    for (var i = 0; i < rules.length; ++i) {
        this.extractByOneRegex(rules[i], scope);
    }

    return this.results;
};

/**
 * Extract fields from an element using the given regex rule.
 * The target string is split into groups by rule.regex and the specified group is choosed to be the extract result value.
 *
 * @param {Object|null} rule extract rule
 *  rule.name : the field name
 *  rule.regex : the regex to split the target string into groups
 *  rule.group : the group number in regex match result, by default, group number is 0 which means the entire string,
 *      if group number is not valid, for example, out of range, it's set to be 0.
 * @param {HTMLElement|null} scope Element to search child elements within,
 *  default scope is document
 * @return Array contains [k, v] pairs
 * */
WarpsDomExtractor.prototype.extractByOneRegex = function (rule, scope) {
    "use strict";

    if (this.verbose) {
        __utils__.log('Extract by one regex', 'debug');
    }

    if (!rule.name || !rule.container || !rule.regex || !rule.group) {
        throw new Error("Invalid regex rule " + JSON.stringify(rule));
    }

    // TODO : scope is useless, use rule.container instead
    if (!scope) {
        scope = document;
    }

    scope = __utils__.findOne(rule.container);

    var k = rule.name;
    var v = null;
    var regex = new RegExp(rule.regex);
    var groupNum = rule.group || 0; // regex group to extract as the result value, 0 means the entire string

    var treeWalker = document.createTreeWalker(
        scope,
        NodeFilter.SHOW_ELEMENT,
        {
            acceptNode: function (node) {
                return NodeFilter.FILTER_ACCEPT;
            }
        },
        false
    );

    while (treeWalker.nextNode()) {
        var node = treeWalker.currentNode;

        if (["DIV", "IMG", "A", "UI", "DL", "H1", "H2", "H3", "H4"].indexOf(node.tagName) == -1) {
            continue;
        }

        // ignore layout nodes
        var descends = __warps_getAttributeAsInt(node, "data-descend", 0);
        if (descends > 10) {
            continue;
        }

        var content = __warps_getMergedTextContent(node);
        if (!content) {
            continue;
        }

        if (content.indexOf(k) !== -1) {
            // this.debugContent(node);
        }

        var groups = content.match(regex);
        if (!groups) {
            continue;
        }

        if (groupNum < 0 || groupNum > groups.length) {
            groupNum = 0;
        }

        v = node;
        content = groups[groupNum].trim();
        if (content.length > 0) {
            var item = {name : k, value : content};
            this.results.push(item);
        }
    } // while

    return this.results;
};

/**
 * Extract fields from an element using css selector or xpath
 *
 * @param rules {Array|null} extract rules
 * @param scope {HTMLElement|null} Element to search child elements within,
 *  default scope is document
 * @return {Array}
 * */
WarpsDomExtractor.prototype.extractBySelector = function (rules, scope) {
    "use strict";
    
    if (this.verbose) {
        __utils__.log('Extract by selector', 'debug');
    }

    for (var i = 0; i < rules.length; ++i) {
        this.extractByOneSelector(rules[i], scope);
    }

    return this.results;
};

/**
 * Extract fields from an element using css selector or xpath
 *
 * @param rules {Array|null} extract rules
 * @param scope {HTMLElement|null} Element to search child elements within,
 *  default scope is document
 * @return Array contains [k, v] pairs
 * */
WarpsDomExtractor.prototype.extractByOneSelector = function (rule, scope) {
    "use strict";
    
    if (this.verbose) {
        __utils__.log('Extract by one selector', 'debug');
    }

    if (!rule.name || !rule.selector) {
        __utils__.log('Invalid rule', 'warn');
        return this.results;
    }

    var k = rule.name;
    var v = __utils__.findAll(rule.selector, scope);

    if (rule.debug) {
        this.__debugContent(rule.key, rule.value, node);
    }

    if (k && v) {
        var item = {name : k, value : __warps_getMergedTextContent(v)};
        this.results.push(item);
    }

    return this.results;
};

/**
 * Extract fields from an element using the given vision rules
 *
 * @param rules {Array} extract rules
 * @param scope {HTMLElement|null} Element to search child elements within,
 *  default scope is document
 * @return Array contains [k, v] pairs
 * */
WarpsDomExtractor.prototype.extractByVision = function (rules, scope) {
    // "use strict";
    //
    // __utils__.log('Extract by vision', 'debug');

    for (var i = 0; i < rules.length; ++i) {
        this.extractByOneVision(rules[i], scope);
    }

    return this.results;
};

/**
 * Extract fields from an element using the given vision rule
 *
 * @param rule {Object|null} extract rule
 * @param scope {HTMLElement|null} Element to search child elements within,
 *  default scope is document
 * @return Array contains [k, v] pairs
 * */
WarpsDomExtractor.prototype.extractByOneVision = function (rule, scope) {
    // "use strict";
    //
    // __utils__.log('Extract by one vision', 'debug');

    if (!rule || !rule.name || !rule.vision) {
        throw new Error("Invalid rule");
    }

    if (!scope) {
        scope = document;
    }

    var k = rule.name;
    var v = null;

    var treeWalker = document.createTreeWalker(
        scope,
        NodeFilter.SHOW_ELEMENT,
        {
            acceptNode: function (node) {
                return NodeFilter.FILTER_ACCEPT;
            }
        },
        false
    );

    while (treeWalker.nextNode()) {
        var node = treeWalker.currentNode;

        // Only block element is considered, this might be refined to add more tags
        const TAGS = ["DIV", "IMG", "A",
            "UL", "OL", "LI",
            "DL",
            "TABLE", "TBODY", "TR",
            "H1", "H2", "H3", "H4"];
        if (TAGS.indexOf(node.tagName) == -1) {
            continue;
        }

        // ignore layout nodes
        var descends = __warps_getAttributeAsInt(node, "data-descend", 0);
        if (descends > 10) {
            continue;
        }

        var content = __warps_getMergedTextContent(node);
        if (!content) {
            continue;
        }

        if (content.indexOf("年份") !== -1) {
            // this.debugContent(node);
        }

        var vision = node.getAttribute("vi");
        if (!vision) {
            continue;
        }

        // convert string to Array, for example, "100 100 100 100" => ["100", "100", "100", "100"]
        vision = vision.split(" ");
        if (vision.length !== 4) {
            continue;
        }

        var match = true;
        var visionRule = rule.vision;
        for (var i = 0; i < 4; ++i) {
            if (!vision[i] || !visionRule.min[i] || !visionRule.max[i]) {
                match = false;
                break;
            }

            // explicitly convert string to integer before comparison
            vision[i] = parseInt(vision[i]);

            // var name = __warps_getReadableNodeName(node);
            // __utils__.echo(name + " : " + vision[i] + ", "
            //     + visionRule.min[i] + ", " + visionRule.max[i]);

            match = (vision[i] >= visionRule.min[i]) && (vision[i] <= visionRule.max[i]);

            // check the next node
            if (!match) {
                break;
            }
        } // for

        if (match) {
            var item = {name : k, value : content};
            this.results.push(item);
        }
    } // while

    return this.results;
};

/**
 * Extract fields from an element using the given rules
 *
 * @param rules {Array|null} extract rules
 * @param scope {HTMLElement|null} Element to search child elements within,
 *  default scope is document
 * @return Array contains [k, v] pairs
 * */
WarpsDomExtractor.prototype.extractByFullRules = function (rules, scope) {
    // "use strict";
    //
    // __utils__.log('Extract by full rules', 'debug');

    if (!rules) {
        return this.results;
    }

    if (!Array.isArray(rules)) {
        var tmp = [].push(rules);
        rules = tmp;
    }

    for (var i = 0; i < rules.length; ++i) {
        var rule = rules[i];
        this.extractByFullRule(rule, scope);
    }

    return this.results;
};

/**
 * Extract fields from an element using the given rule
 *
 * @param  rule {Object} Extract rule
 * @param  scope {HTMLElement|null} Element to search child elements within,
 *  default scope is document
 * @return Array contains [k, v] pairs
 * */
WarpsDomExtractor.prototype.extractByFullRule = function (rule, scope) {
    "use strict";

    __utils__.log('Extract by full rule', 'debug');

    if (rule.selector) {
        this.extractBySelector(rule, scope);
    }
    if (rule.regex) {
        this.extractByRegex(rule, scope);
    }
    if (rule.vision) {
        this.extractByVision(rule, scope);
    }
    if (rule.kv) {
        this.extractByOneKVRule(rule, scope);
    }

    // var validateRate = 0.1;
    // if (1 < validateRate) {
    //     // TODO : use a mechanism to validate some of the samples
    //     return this.results;
    // }

    // var resultNotValidated = this.results;
    // this.results = [];

    // var valid = false;
    // if (rule.validator.selector) {
    //     var v2 = __utils__.findOne(rule.validator.xpath, scope);
    //     valid = (content == v2.textContent.trim());
    // }
    // if (rule.validator.regex) {
    //     valid = content.match(new RegExp(rule.validator.regex));
    // }
    // if (rule.validator.vision) {
    // }
    //
    // if (valid) {
    //     this.results.push([k, content]);
    // }

    return this.results;
};

/**
 * Extract fields from an element using the given rules
 *
 * @param rules {Array|null} extract rules
 * @param  scope {HTMLElement|null} Element to search child elements within,
 *  default scope is document
 * @return {Array}
 * */
WarpsDomExtractor.prototype.extractByKVRules = function (rules, scope) {
    // "use strict";
    //
    // __utils__.log('Extract by KV rules', 'debug');

    for (var i = 0; i < rules.length; ++i) {
        this.extractByOneKVRule(rules[i], scope);
    }

    return this.results;
};


/**
 * Extract fields from an element using the given rule
 *
 * @param rule {Object|null} extract rule
 * @param  scope {HTMLElement|null} Element to search child elements within,
 *  default scope is document
 * @return {Array}
 * */
WarpsDomExtractor.prototype.extractByOneKVRule = function (rule, scope) {
    "use strict";

    __utils__.log('Extract by one KV rule', 'debug');

    if (!rule || !rule.collection || !rule.key || !rule.value) {
        throw new Error("Invalid extract rule : " + JSON.stringify(rule));
    }

    if (!scope) {
        scope = document;
    }

    var nodeList = __utils__.findAll(rule.collection, scope);
    for (var i = 0; i < nodeList.length; ++i) {
        var node = nodeList[i];

        var k = __utils__.findAll(rule.key, node);
        var v = __utils__.findAll(rule.value, node);

        if (rule.debug) {
            this.__debugContent(rule.key, rule.value, node);
        }

        k = __warps_getMergedTextContent(k);
        v = __warps_getMergedTextContent(v);
        if (k && k.length > 0 && v && v.length > 0 ) {
            var item = {name : k, value : v};
            this.results.push(item);
        }
    }

    return this.results;
};

/**
 * Extract fields from an element using the given rules
 *
 * @param rules {Array|null} extract rules
 * @param  scope {HTMLElement|null} Element to search child elements within,
 *  default scope is document
 * @return {Array}
 * */
WarpsDomExtractor.prototype.extractCollections = function (rules, scope) {
    "use strict";

    __utils__.log('Extract by collections', 'debug');

    for (var i = 0; i < rules.length; ++i) {
        this.extractCollection(rules[i], scope);
    }

    return this.results;
};

/**
 * Extract fields from an element using the given rule
 *
 * @param  rule {Object} Extract rule
 * @param  scope {HTMLElement|null} Element to search child elements within,
 *  default scope is document
 * @return Array contains [k, v] pairs
 * */
WarpsDomExtractor.prototype.extractCollection = function (rule, scope) {
    "use strict";

    __utils__.log('Extract collection', 'debug');

    if (!rule || !rule.name || !rule.container || !rule.collection) {
        throw new Error("Invalid extract rule : " + JSON.stringify(rule));
    }

    if (!scope) {
        scope = document;
    }

    // var containerNode = __utils__.findOne(rule.container, scope);
    // var k = rule.name;
    var nodeList = __utils__.findAll(rule.collection, scope);
    if (!nodeList) {
        __utils__.log('Find nothing with selector ' + rule.container + ' ' + rule.collection, 'warning');
        return this.results;
    }

    var name = rule.name;
    var entities = [];
    for (var i = 0; i < nodeList.length; ++i) {
        var node = nodeList[i];
        var options = {};
        options.metadata = false;
        var entity = new WarpsDomExtractor(rule.extractor, options).extract(node);
        entities.push(entity);
    }
    // this.results.push([name, entities, "collection"]);
    var item = {name : name, value : entities, type : "collection"};
    this.results.push(item);

    return this.results;
};

/**
 * Validate
 * */
WarpsDomExtractor.prototype.validate = function () {
    // "use strict";

    __utils__.log('Validate', 'debug');
};

WarpsDomExtractor.prototype.__debugContent = function (ruleKey, ruleValue, scope) {
    // "use strict";

    var k = __utils__.findAll(ruleKey, scope);
    var v = __utils__.findAll(ruleValue, scope);

    __utils__.echo(i + " : " +
        __warps_getReadableNodeName(scope) +
        ", " + ruleKey +
        ", " + ruleValue +
        ", " + (k ? __warps_getMergedTextContent(k) : "") +
        " : " + (v ? __warps_getMergedTextContent(v) : "")
    );
};

/**
 * Original script file : src/lib/client/weibo_extractor.js. 
 **/

"use strict";

/**
 * Weibo page extractor
 * */
var WeiboExtractor = function WeiboExtractor() {
};

/**
 * Extract fields from an element using the given rule
 *
 * @param feedElement {HTMLElement|null} Element to search child elements within,
 *  default scope is window.document
 * @return Object
 * */
WeiboExtractor.prototype.extract = function(feedElement) {
    var feed = this.extractFeed(feedElement);

    return feed;
};

/**
 * @param feedElement {HTMLElement|null}
 * @return Object
 * */
WeiboExtractor.prototype.extractFeed = function (feedElement) {
    "use strict";

    var v;

    v = __utils__.findOne('.WB_detail > .WB_info', feedElement);
    var author = __warps_getMergedTextContent(v);

    v = __utils__.findOne('.WB_from a[href*="weibotime"]', feedElement);
    var time = __warps_getMergedTextContent(v);

    v = __utils__.findOne('.WB_from a[action-type*="app_source"]', feedElement);
    var app = __warps_getMergedTextContent(v);

    v = __utils__.findOne('div[node-type*="feed_list_content"]', feedElement);
    var content = __warps_getMergedTextContent(v);

    var feedExpand = this.extractExpandFeed(feedElement);

    return {author : author, time : time, app : app, content : content, feedExpand : feedExpand};
};

/**
 * @param feedElement {HTMLElement|null}
 * @return Object
 * */
WeiboExtractor.prototype.extractExpandFeed = function (feedElement) {
    "use strict";

    var v = __utils__.findOne('.WB_feed_expand', feedElement);
    var feedExpand = __warps_getMergedTextContent(v);

    return {content : feedExpand};
};

/**
 * @param feed {Object}
 * @return String
 * */
WeiboExtractor.prototype.formatFeed = function (feed) {
    "use strict";

    var feedString = "";
    feedString += "author : " + feed.author + "\n";
    feedString += "time : " + feed.time + "\n";

    if (feed.app) {
        feedString += "app : " + feed.app + "\n";
    }
    
    feedString += "content : " + feed.content + "\n";

    if (feed.feedExpand.content) {
        feedString += "feedExpand : " + feed.feedExpand.content + "\n";
    }

    return feedString;
};

