/**
 * This file is automatically generated by satellite framework, please *DO NOT* modify the file. 
 * Generate time : Fri May 27 2016 21:13:46 GMT+0800 (CST). 
 **/

/**
 * Original script file : src/lib/client/clientutils.js. 
 **/

const META_INFORMATION_ID = "QiwurScrapingMetaInformation";

/**
 * TODO : move all free functions into a class
 * */

function __qiwur__visualizeHumanize() {
	var metadata = document.querySelector("#" + META_INFORMATION_ID);
	if (metadata) {
        // already exists
        return;
	}

	var visionSchema = ["top", "left", "width", "height"];
    var visionSchemaString = "top-left-width-height";

	document.body.setAttribute("data-url", document.URL);

	var ele = document.createElement("input");
	ele.setAttribute("type", "hidden");
	ele.setAttribute("id", META_INFORMATION_ID);
	ele.setAttribute("data-domain", document.domain);
	/**
	 * MetaInformation version :
	 * No version : as the same as 0.1.0, the first div was selected as the holder
	 * 0.2.0 : add a input element at the end of body element
	 * 0.2.1 : add "vi" attribute for each (important) element, deprecate "data-" series 
	 * 		to deduce file size
	 * */
	// ele.setAttribute("data-version", "0.2.0");
	ele.setAttribute("data-version", "0.2.1");
	ele.setAttribute("data-url", document.URL);
	ele.setAttribute("data-base-uri", document.baseURI);
	ele.setAttribute("data-vision-schema", visionSchemaString);
	document.body.appendChild(ele);

	__qiwur__visualize(document.body, visionSchema);
	__qiwur__humanize(document.body);

	// if any script error occurs, the flag can NOT be seen
	document.body.setAttribute("data-error", '0');
}

/**
 * Fetch all <a> elements from the page and return
 * the ones which contains a href starting with 'http://'
 * 
 * @param mainAreaSelector main area selector
 * @param urlRegex url regex in main area
 * 
 * */
function __qiwur__searchLinks(mainAreaSelector, urlRegex) {
	var filter = Array.prototype.filter;
	var map = Array.prototype.map;

	// __utils__.echo('------------');
	// __utils__.echo(mainAreaSelector + " a");

	var links = document.querySelectorAll(mainAreaSelector + " a");
	return map.call(filter.call(links, function(link) {
		return new RegExp(urlRegex).test(link.href);
	}), function(link) {
		return link.href;
	});
}

function __qiwur__relativeToAbsolute(url) {
	if (url.indexOf("//") == 0) {
		url = "http:" + url;
	}

    var arr = url.split("/") // Cut the url up into a array
    while(!!~arr.indexOf("..")){ // If there still is a ".." in the array
        arr.splice(arr.indexOf("..") - 1, 2); // Remove the ".." and the element before it.
    }
    return arr.join("/"); // Rebuild the url and return it.
}

function __qiwur_createCaptureArea(captureAreaSelector) {
	jQuery("<div class='QiwurCaptureArea' style='top:0; left:0; width:1000px; height:400px; z-index:1000; display:block'>" +
			"<div class='holder' style='position:relative; top:0px; left:20px; min-width:20px; min-height:20px; padding:0 40px; display:block'></div>" +
			"</div>")
		.prependTo('body');

	var holder = jQuery('.QiwurCaptureArea > div.holder');
	var target = jQuery(captureAreaSelector);
	// __utils__.echo("Target tag name " + target.prop('tagName'));
	var counter = 4;
	while (target.prop('tagName') != 'DIV' && counter-- > 0) {
		target = target.parent();
	}
	holder.append(target.clone());
	holder.width(target.width());
	holder.height(target.height());
}

function __qiwur_cleanCaptureArea() {
	jQuery('.QiwurCaptureArea').remove();
}

function __qiwur_insertImage(nearBy, name, imagePath) {
	var counter = 4;
	var neighbor = jQuery(nearBy);
	while (neighbor.prop('tagName') != 'DIV' && counter-- > 0) {
		neighbor = neighbor.parent();
	}

	var insert = neighbor.clone().html('')
		.attr('class', 'monitor-inserted')
		.attr('name', name)
		.attr('value', imagePath)
		.attr('label', 'Captured');
	var image = "<img src='" + imagePath + "' />";
	insert.append('<div>' + name + '</div>');
	insert.append('<div>' + image + '</div>');

	neighbor.after(insert);
}

/**
 * Get attribute as an integer
 * */
function __qiwur_getAttributeAsInt(node, attrName, defaultValue) {
    if (!defaultValue) {
        defaultValue = 0;
    }

    var value = node.getAttribute(attrName);
    if (!value) {
        value = defaultValue;
    }

    return parseInt(value);
}

/**
 * Get attribute as an integer
 * */
function __qiwur_getReadableNodeName(node) {
    var name = node.tagName
    + (node.id ? ("#" + node.id) : "")
    + (node.className ? ("#" + node.className) : "");

    var seq = __qiwur_getAttributeAsInt(node, "_seq", -1);
    if (seq >= 0) {
        name += "-" + seq;
    }

    return name;
}

/**
 * Original script file : src/lib/client/element_traversor.js. 
 **/

/**
 * Created by vincent on 16-5-17.
 */

"use strict";

/**
 * Create a new traversor.
 * @param visitor {ElementVisitor} a class implementing the {@link ElementVisitor} interface, to be called when visiting each ele.
 * @param options {Object} options, currently, only one option : options.diagnosis(= false);
 */
function ElementTraversor(visitor) {
    this.visitor = visitor;
    this.options = {
        diagnosis : false
    };

    var options = null;
    if (arguments.length > 1) {
        options = arguments[1];
    }
    if (options) {
        // override default options
        for (var prop in options) {
            if (options[prop]) {
                this.options[prop] = options[prop];
            }
        }
    }
}

/**
 * Start a depth-first traverse of the root and all of its descendants.
 * @param root {HTMLElement} the root ele point to traverse.
 */
ElementTraversor.prototype.traverse = function(root) {
    if (!root) {
        __utils__.log("Invalid root to traverse.", "warn");
        return;
    }
    
    var ele = root;
    var depth = 0;
    
    while (ele) {
        this.visitor.head(ele, depth);

        if (ele.children.length > 0) {
            ele = ele.children[0];
            depth++;
        } else {
            while (!ele.nextElementSibling && depth > 0) {
                this.visitor.tail(ele, depth);
                ele = ele.parentNode;
                depth--;
                
                if (this.options.diagnosis) {
                    this.diagnosis(ele);
                }
            }
            
            this.visitor.tail(ele, depth);
            if (ele == root) {
                // __utils__.echo("-----back to root, depth " + depth);
                break;
            }
            
            ele = ele.nextElementSibling;
        }
    }
};

ElementTraversor.prototype.diagnosis = function(ele, depth) {
    var info = ele + ", nodeType : " + ele.nodeType + ", nodeName : " + ele.nodeName;

    if (ele.nodeName === "A") {
        info += ", children count : " + ele.children.length;
        for (var i = 0; i < ele.children.length; ++i) {
            info += ", " + ele.children[i].nodeName;
        }
    }

    __utils__.echo(info);
};

/**
 * Original script file : src/lib/client/element_visitor.js. 
 **/

/**
 * Created by vincent on 16-5-17.
 */

"use strict";

/**
 * Create a new ElementVisitor.
 */
var ElementVisitor = function() {
    // TODO : use a schema to record all features
    // this.schema = ["descend"];
    this.sequence = 0;
};

/**
 * Enter the element for the first time
 * @param ele {HTMLElement} the ele to enter
 * @param  depth {Number} the depth in the DOM
 */
ElementVisitor.prototype.head = function(ele, depth) {
    ele.setAttribute("_descend", "0");
    this.calcSelfIndicator(ele);
};

/**
 * About to leaving the the element
 * @param ele {HTMLElement} the ele visited
 */
ElementVisitor.prototype.tail = function(ele, depth) {
    var current = ele;
    var parent = current.parentNode;

    if (!parent) {
        return;
    }

    var myDescends = __qiwur_getAttributeAsInt(current, "_descend", 0);
    var lastParentDescends = __qiwur_getAttributeAsInt(parent, "_descend", 0);
    var currentParentDescends = lastParentDescends + myDescends + 1;

    // this.report(ele);

    parent.setAttribute("_descend", currentParentDescends);
};

/**
 * Calculate the give element statistic information
 * @param ele {HTMLElement} the element to calculate
 */
ElementVisitor.prototype.calcSelfIndicator = function(ele) {
    // var descend = __qiwur_getAttributeAsInt(ele, "_descend", 0);
    //
    ele.setAttribute("_seq", ++this.sequence);
};

/**
 * report the element statistic information
 * @param ele {HTMLElement} the element to report
 */
ElementVisitor.prototype.report = function(ele) {
    __utils__.echo(ele.tagName
        + (ele.id ? ("#" + ele.id) : "")
        + (ele.className ? ("#" + ele.className) : "")
        + " has " + currentParentDescends + " descends");
}

/**
 * Original script file : src/lib/client/extractor.js. 
 **/

const RuleSchema = {
    extractor : {
        slim : ["k1", "v1", "k2", "v2", "k3", "v3"],
        full : [
            {
                "name": "entity-source",
                "cssPath": ".entity-source",
                "validator": {
                    "regex": ".+",
                    "xpath": null
                },
                "min-left": null,
                "max-left": null,
                "min-top": null,
                "max-top": null,
                "min-width": null,
                "max-width": null,
                "min-height": null,
                "max-height": null
            }
        ],
        kv : [
            {
                "name": "publication",
                "container": ".entity-section div",
                "key": " > span",
                "value": " > p"
            }
        ]
    }
};

// Note : seems can not come before constants
"use strict";

/**
 * Page extractor
 * @param  HTMLElement|null  options     extract rules
 * */
var Extractor = function Extractor(extractor) {
    "use strict";
    
    this.extractor = extractor;
    this.results = [];
};

/**
 * Extract fields from an element using the given rule
 *
 * @param  HTMLElement|null  scope     Element to search child elements within,
 *  default scope is window.document
 * @return
 * */
Extractor.prototype.extract = function(scope) {
    "use strict";
    var rules = this.extractor.slim;
    if (rules && rules.length % 2 !== 0) {
        throw new Error("Slim extractor rules length should be an even number");
        return;
    }

    scope = scope || window.document;
    
    try {
        this.extractBySlimRules(scope);
        this.extractByFullRules(scope);
        this.extractByKVRules(scope);
    }
    catch (e) {
        __utils__.log(e, "error");
    }
    
    return this.results;
};

/**
 * Extract fields from an element using the given rule
 *
 * @param  HTMLElement|null  scope     Element to search child elements within, 
 *  default scope is document
 * @return
 * */
Extractor.prototype.extractBySlimRules = function(scope) {
    "use strict";
    var rules = this.extractor.slim;
    if (!rules) {
        return;
    }
    if (rules.length % 2 !== 0) {
        __utils__.log('Slim extractor rules length must be even number', 'warn');
        return;
    }

    for (var i = 0; i < rules.length - 1; i += 2) {
        var k = rules[i];
        var selector = rules[i + 1];
        var v = __utils__.findOne(selector, scope);

        if (v && v.textContent) {
            this.results.push([k, v.textContent.trim()]);
        }
    }
    
    return this.results;
};

/**
 * Extract fields from an element using the given regex rule
 *
 * @param {Array|null} extract rules
 * @param {HTMLElement|null} scope Element to search child elements within,
 *  default scope is document
 * @return
 * */
Extractor.prototype.extractByRegex = function(rules, scope) {
    for (var i = 0; i < rules.length; ++i) {
        this.extractByOneRegex(rules[i]);
    }

    return this.results;
};

/**
 * Extract fields from an element using the given regex rule.
 * The target string is split into groups by rule.regex and the specified group is choosed to be the extract result value.
 *
 * @param {Object|null} extract rule
 *  rule.name : the field name
 *  rule.regex : the regex to split the target string into groups
 *  rule.group : the group number in regex match result, by default, group number is 0 which means the entire string,
 *      if group number is not valid, for example, out of range, it's set to be 0.
 * @param {HTMLElement|null} scope Element to search child elements within,
 *  default scope is document
 * @return {Array}
 * */
Extractor.prototype.extractByOneRegex = function(rule, scope) {
    "use strict";

    if (!rule.regex) {
        throw new Error("Invalid rule");
        return;
    }

    if (!scope) {
        scope = document;
    }

    var k = rule.name;
    var v = null;
    var regex = new RegExp(rule.regex);
    var groupNum = rule.group || 0; // regex group to extract as the result value, 0 means the entire string

    var treeWalker = document.createTreeWalker(
        scope,
        NodeFilter.SHOW_ELEMENT,
        {
            acceptNode : function(node) { return NodeFilter.FILTER_ACCEPT; }
        },
        false
    );

    while(treeWalker.nextNode()) {
        var node = treeWalker.currentNode;

        if (["DIV", "IMG", "A", "UI", "DL", "H1", "H2", "H3", "H4"].indexOf(node.tagName) == -1) {
            continue;
        }

        // ignore layout nodes
        var descends = __qiwur_getAttributeAsInt(node, "data-descend", 0);
        if (descends > 10) {
            continue;
        }
        
        var content = this.getTextContent(node);
        if (!content) {
            continue;
        }

        if (content.indexOf("年份") !== -1) {
            // this.debugContent(node);
        }

        var groups = content.match(regex);
        if (!groups) {
            continue;
        }

        if (groupNum < 0 || groupNum > groups.length) {
            groupNum = 0;
        }

        v = node;
        content = groups[groupNum];
        this.results.push([k, content.trim()]);
    }

    return this.results;
};

/**
 * Extract fields from an element using the given vision rule
 *
 * @param rules {Object|null} extract rules
 * @param scope {HTMLElement|null} Element to search child elements within,
 *  default scope is document
 * @return {Array}
 * */
Extractor.prototype.extractByVision = function(rules, scope) {
    for (var i = 0; i < rules.length; ++i) {
        this.extractByOneVision(rules[i]);
    }
    
    return this.results;
};

/**
 * Extract fields from an element using the given vision rule
 *
 * @param rule {Object|null} extract rule
 * @param scope {HTMLElement|null} Element to search child elements within,
 *  default scope is document
 * @return {Array}
 * */
Extractor.prototype.extractByOneVision = function(rule, scope) {
    "use strict";

    if (!rule || !rule.name || !rule.vision) {
        throw new Error("Invalid rule");
        return;
    }

    if (!scope) {
        scope = document;
    }

    var k = rule.name;
    var v = null;

    var treeWalker = document.createTreeWalker(
        scope,
        NodeFilter.SHOW_ELEMENT,
        {
            acceptNode : function(node) { return NodeFilter.FILTER_ACCEPT; }
        },
        false
    );

    while(treeWalker.nextNode()) {
        var node = treeWalker.currentNode;

        // Only block element is considered, this might be refined to add more tags
        if (["DIV", "IMG", "A", "UI", "DL", "H1", "H2", "H3", "H4"].indexOf(node.tagName) == -1) {
            continue;
        }

        // ignore layout nodes
        var descends = __qiwur_getAttributeAsInt(node, "data-descend", 0);
        if (descends > 10) {
            continue;
        }

        var content = this.getTextContent(node);
        if (!content) {
            continue;
        }

        if (content.indexOf("年份") !== -1) {
            // this.debugContent(node);
        }

        var vision = node.getAttribute("vi");
        if (!vision) {
            continue;
        }

        // convert string to array, for example, "100 100 100 100" => ["100", "100", "100", "100"]
        vision = vision.split(" ");
        if (vision.length !== 4) {
            continue;
        }

        var match = true;
        var visionRule = rule.vision;
        for (var i = 0; i < 4; ++i) {
            if (!vision[i] || !visionRule.min[i] || !visionRule.max[i]) {
                match = false;
                break;
            }

            // explicitly convert string to integer before comparison
            vision[i] = parseInt(vision[i]);

            // var name = __qiwur_getReadableNodeName(node);
            // __utils__.echo(name + " : " + vision[i] + ", "
            //     + visionRule.min[i] + ", " + visionRule.max[i]);

            match = (vision[i] >= visionRule.min[i]) && (vision[i] <= visionRule.max[i]);

            // check the next node
            if (!match) {
                break;
            }
        }

        if (match) {
            v = node;
            this.results.push([k, content]);
        }
    } // while

    return this.results;
};

/**
 * Extract fields from an element using the given rule
 *
 * @param  rule {Object} Extract rule
 * @param  scope {HTMLElement|null} Element to search child elements within,
 *  default scope is document
 * @return
 * */
Extractor.prototype.extractByFullRule = function(rule, scope) {
    "use strict";

    if (!rule.name || !rule.cssPath) {
        __utils__.log('Full extract rule must have fields name and cssPath', 'warn');
        return;
    }

    var k = rule.name;
    var v = null;
    if (rule.cssPath) {
        v = __utils__.findOne(rule.cssPath, scope);
    }
    if (!v && rule.xpath) {
        v = __utils__.findOne(rule.xpath, scope);
    }
    if (!v && rule.regex) {
        this.extractByRegex(rule, scope);
    }
    if (!v && rule.vision) {
        this.extractByVision(rule, scope);
    }

    var content = this.getTextContent(v);
    if (!content) {
        return;
    }

    var validateRate = 0.1;
    if (1 < validateRate) {
        // TODO : use a mechanism to validate some of the samples
        return;
    }

    var valid = false;
    if (rule.validator.cssPath) {
        var v2 = __utils__.findOne(rule.validator.xpath, scope);
        valid = (content == v2.textContent.trim());
    }
    if (rule.validator.xpath) {
        var v2 = __utils__.findOne(rule.validator.xpath, scope);
        valid = (content == v2.textContent.trim());
    }
    if (rule.validator.regex) {
        valid = content.match(new RegExp(rule.validator.regex));
    }
    if (rule.validator.vision) {
    }

    if (valid) {
        this.results.push([k, content]);
    }

    return this.results;
};

/**
 * Extract fields from an element using the given rules
 *
 * @param  HTMLElement|null  scope     Element to search child elements within,
 *  default scope is document
 * @return
 * */
Extractor.prototype.extractByFullRules = function(scope) {
    "use strict";

    var rules = this.extractor.full;
    if (!rules) {
        return;
    }

    if (!Array.isArray(rules)) {
        var tmp = [].push(rules);
        rules = tmp;
    }

    for (var i = 0; i < rules.length; ++i) {
        var rule = rules[i];
        this.extractByFullRule(rule, scope);
    }
};

/**
 * Extract fields from an element using the given rule
 *
 * @param  scope {HTMLElement|null} Element to search child elements within,
 *  default scope is document
 * @return
 * */
Extractor.prototype.extractByKVRules = function(scope) {
    var rules = this.extractor.kv;
    if (!rules) {
        return;
    }

    var type = typeof rules;

    if (type === 'object') {
        var tmp = [].push(rules);
        rules = tmp;
    }

    if (!Array.isArray(rules)) {
        throw new Error("Unsupported rules type: " + (typeof rules));
    }

    return this.results;
};

/**
 * Clean element's textContent
 * @param textContent {String} the string to clean
 * @return The clean string
 * */
Extractor.prototype.cleanTextContent = function(textContent) {
    textContent = textContent.replace(/\s+/g, " "); // combine all blanks into one " " character
    return textContent.trim();
};

/**
 * Get cleared element's textContent
 * @param content {String} the string to clean
 * @return {String} The cleared string, "" if no element text content available.
 * */
Extractor.prototype.getTextContent = function(node) {
    if (!node || !node.textContent) {
        return "";
    }

    var content = this.cleanTextContent(node.textContent);

    return content;
};

Extractor.prototype.debugContent = function(scope) {
    var content = scope.textContent.trim();
    // content = content.replace(/\n/g, "");

    __utils__.echo("-------------debug content-----------------");
    var s = "";
    for (var i = 0; i < content.length; ++i) {
        s += content.charAt(i) + content.charCodeAt(i) + ",";
    }
    __utils__.echo(s);
    __utils__.echo("-------------debug content-----------------");
};


/**
 * Original script file : src/lib/client/humanize.js. 
 **/

var MAX_EVENT_COUNT = 30;

/**
 * TODO : move all free functions into a class
 * */

/**
 * Fire an event handler to the specified node. Event handlers can detect that
 * the event was fired programatically by testing for a 'synthetic=true'
 * property on the event object
 * 
 * @param {HTMLNode}
 *            node The node to fire the event handler on.
 * @param {String}
 *            eventName The name of the event without the "on" (e.g., "focus")
 */
function __qiwur__fireEvent(node, eventName) {
    // Make sure we use the ownerDocument from the provided node to avoid
    // cross-window problems
    var doc;
    if (node.ownerDocument) {
        doc = node.ownerDocument;
    } else if (node.nodeType == 9) {
        // the node may be the document itself, nodeType 9 = DOCUMENT_NODE
        doc = node;
    } else {
        throw new Error("Invalid node passed to fireEvent: " + node.id);
    }

    if (node.dispatchEvent) {
        // Gecko-style approach (now the standard) takes more work
        var eventClass = "";

        // Different events have different event classes.
        // If this switch statement can't map an eventName to an eventClass,
        // the event firing is going to fail.
        switch (eventName) {
        case "click": // Dispatching of 'click' appears to not work correctly
                        // in Safari. Use 'mousedown' or 'mouseup' instead.
        case "mousedown":
        case "mouseup":
        case "mouseover":
            eventClass = "MouseEvents";
            break;

        case "focus":
        case "change":
        case "blur":
        case "select":
            eventClass = "HTMLEvents";
            break;

        default:
            throw "fireEvent: Couldn't find an event class for event '"
                    + eventName + "'.";
            break;
        }
        var event = doc.createEvent(eventClass);

        var bubbles = eventName == "change" ? false : true;
        event.initEvent(eventName, bubbles, true); // All events created as
                                                    // bubbling and cancelable.

        event.synthetic = true; // allow detection of synthetic events
        node.dispatchEvent(event, true);
    } else if (node.fireEvent) {
        // IE-old school style
        var event = doc.createEventObject();
        event.synthetic = true; // allow detection of synthetic events
        node.fireEvent("on" + eventName, event);
    }
};

function __qiwur__humanize(doc) {
    // mouse over and click each link, notice that the navigation is locked, so it's OK to click the link
    // notice : do not use document.links since it ignores <a> tag without href attribute
    var links = doc.getElementsByTagName("a");
    var eventCount = 0;
    for (var i = 0; i < links.length && eventCount < MAX_EVENT_COUNT; ++i) {
        var link = links[i];

        var noTarget = !link.href;
        noTarget |= link.href.indexOf('void') == 0;
        noTarget |= link.href.indexOf('#') == 0;
        noTarget |= link.href.indexOf('java') == 0;
        noTarget |= link.href.indexOf('script') == 0;

        var hasEvent = link.hasAttribute('onmousedown');
        hasEvent |= link.hasAttribute('onmouseup');
        hasEvent |= link.hasAttribute('onmouseover');
//      hasEvent |= link.hasAttribute('onclick');

        if (noTarget || hasEvent) {
//            __qiwur__fireEvent(link, 'mousedown');
//            __qiwur__fireEvent(link, 'mouseup');
            __qiwur__fireEvent(link, 'mouseover');

            // TODO : research : a click event contains mousedown, mouseup and mouseover?
//            __qiwur__fireEvent(link, 'click');
            ++eventCount;

            // if any script error occurs, the flag can NOT be seen
            link.setAttribute('data-event-fired', eventCount);
        }
    }

    var fireImageEvent = false;
    if (fireImageEvent) {
        // mouse over and click each image
        var images = doc.getElementsByTagName("img");
        for (var i = 0; i < images.length; ++i) {
            var image = images[i];

            __qiwur__fireEvent(image, 'mousedown');
            __qiwur__fireEvent(image, 'mouseup');
            __qiwur__fireEvent(image, 'mouseover');
            __qiwur__fireEvent(image, 'click');

            // if any script error occurs, the flag can NOT be seen
            image.setAttribute('data-event-fired', 1);
        }
    }
}

/**
 * Original script file : src/lib/client/visualize.js. 
 **/


/**
 * TODO : move all free functions into a class
 * */

/**
 * Get element offset
 * @return [top, left]
 * */
function __qiwur__getOffset(ele) {
    var x = 0;
    var y = 0;

    while(ele && !isNaN(ele.offsetLeft) && !isNaN(ele.offsetTop)) {
    	x += ele.offsetLeft - ele.scrollLeft;
        y += ele.offsetTop - ele.scrollTop;

        ele = ele.offsetParent;
    }

    return { top: y, left: x };
}

/**
 * Set robot(monitor) defined element attribute
 * @return [top, left]
 * */
function __qiwur__setAttribute(ele, key, value) {
    if (value != "0" && value != "0px" && value != "auto") {
        // value.match(/[1-9]d+px/g);
        ele.setAttribute(key, value);
    }
}

/**
 * @Deprecated
 * */
function __qiwur__setVisionInfoFull(ele) {
	var offset = __qiwur__getOffset(ele);

    __qiwur__setAttribute(ele, 'data-top', offset.top);
    __qiwur__setAttribute(ele, 'data-left', offset.left);

    if (window.getComputedStyle) {
        var style = window.getComputedStyle(ele, null);
        __qiwur__setAttribute(ele, 'data-top', style.getPropertyValue("top"));
        __qiwur__setAttribute(ele, 'data-left', style.getPropertyValue("left"));
        __qiwur__setAttribute(ele, 'data-width', style.getPropertyValue("width"));
        __qiwur__setAttribute(ele, 'data-height', style.getPropertyValue("height"));
    }
    else {
        __qiwur__setAttribute(ele, 'data-client-height', ele.clientHeight);
        __qiwur__setAttribute(ele, 'data-client-width', ele.clientWidth);

        __qiwur__setAttribute(ele, 'data-offset-height', ele.offsetHeight);
        __qiwur__setAttribute(ele, 'data-offset-width', ele.offsetWidth);
        __qiwur__setAttribute(ele, 'data-offset-left', ele.offsetLeft);
        __qiwur__setAttribute(ele, 'data-offset-top', ele.offsetTop);

        __qiwur__setAttribute(ele, 'data-scroll-height', ele.scrollHeight);
        __qiwur__setAttribute(ele, 'data-scroll-width', ele.scrollWidth);
        __qiwur__setAttribute(ele, 'data-scroll-left', ele.scrollLeft);
        __qiwur__setAttribute(ele, 'data-scroll-top', ele.scrollTop);
    }

    __qiwur__setAttribute(ele, 'data-visualized', 1);
}

/**
 * Visual information. To minimize the document size,
 * we write only the values according to the given schema.
 * 
 * For example : 
 * <div class="product" vi="236 470 980 30">...</div>
 * */
function __qiwur__getVisionInfo(ele, schema) {
	var vision = "";

	var style = window.getComputedStyle(ele, null);
	var offset = __qiwur__getOffset(ele);

	var allZero = true;
	for (var i = 0; i < schema.length; ++i) {
		if (i > 0) {
			vision += " ";
		}

		var key = schema[i];
		var value = "";

		if (key == "top") {
			value = offset.top;
		}
		else if (key == "left") {
			value = offset.left;
		}
		else {
			value = style.getPropertyValue(key);
			value = value.replace("px", "");
		}

		if (value != 0 && !isNaN(value)) {
			allZero = false;
		}

		vision += value;
	}

	return allZero ? false : vision;
}

/**
 * Compute descendents number
 * */
function __qiwur__getDescendentsNumber(ele) {
	//
	for(var i = 0; i < ele.childNodes.length; i++) {
		__qiwur__visualize(ele.childNodes[i], schema);
	}
}

var nodeWorker = function(visitor) {
	function walk(ele) {
		visitor.head(ele);
		visitor.visit(ele);
		visitor.tail(ele);
	}
};

/**
 * Compute visualization information
 * */
function __qiwur__visualize(ele, schema) {
	if (["BODY", "DIV", "A", "IMG", "TABLE", "UL", "DL", "H1", "H2"].indexOf(ele.tagName) != -1) {
		var vision = __qiwur__getVisionInfo(ele, schema);
		if (vision) {
			ele.setAttribute('vi', vision);
		}
	}

    for(var i = 0; i < ele.childNodes.length; i++) {
    	__qiwur__visualize(ele.childNodes[i], schema);
    }
}

/**
 * Compute visualization information
 * */
function __qiwur__visualize2(ele, schema) {
	new ElementTraversor(new ElementVisitor()).traverse(ele);
}

